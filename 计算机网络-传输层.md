# 1、IP协议

- 端口号：使用16比特表示，取值范围0-65535
  - 熟知端口号：0～1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如：FTP
    使用21/20，HTTP使用80，DNS使用53。
  - 登记端口号：1024~49151，为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定
    的手续登记，以防止重复。例如：Microsoft RDP 微软远程桌面使用的端口是3389。
  - 短暂端口号：49152～65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知
    道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。

- 端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中，
  不同计算机中的相同端口号是没有联系的。
- tcp或者dup协议都需要封装为ip协议，更具协议字段进行区分，tcp为6，udp为17

# 2、TCP



- 熟知端口号

  - SMTP 25
  - FTP 21/20
  - BGP 179
  - HTTP 80
  - HTTPS 443 

- 流量控制

  - 一般来说我们喜欢数据传输的更快一些，但是如果发送方把数据发送的过快，接收到就可能来不及接收，这就会造成数据的丢失
  - 所谓的流量控制就是发送方的发送速率不要太快，要让接收方来得及接收
  - 利用滑动窗口机制可以很方便的在tcp链接上实现对发送发的流量控制

- 滑动窗口

- 拥塞控制

  - 慢开始
  - 拥塞避免
  - 快重传
  - 快恢复 

- 客户端状态流转

  > 关闭 -- 同步已发送-- 连接已建立

- 服务端状态流转

  > 关闭 -- 监听 --- 同步已接收 --- 连接已建立

- 三次握手

  - tcp服务端从closed状态被动打开状态变化为listen等待客户端的连接
  - tcp客户端从closed状态主动发起建立连接报文段: SYN=1 seq=x(初始序号，不携带数据，消耗一个序号)
  - tcp服务端接收到链接请求后会送确认连接请求的报文段：SYN=1 ACK=1 seq=y ack=x+1(消耗序号，不携带数据，消耗一个序号) 状态变为SYN-RCVD同步已接收
  - tcp客户端接收到服务端确定连接报文后，发送普通确认报文段：ACK=1 seq=x+1 ack=y+1（可以携带数据，如果不携带数据则不消耗序号） 状态变为ESTABLISHED连接已建立

  > 采用3报文确定而不是两报文确认？
  >
  > 是为了方式因为网络传输延时造成的连接请求滞后带来的影响
  >
  > 比如客户端发起一个连接请求，因为网络问题导致超时，客户端会进行连接报文重传，服务端接收后会送确认连接请求，建立连接，双方传输结束后经过四次挥手断开连接，这时客户端处于断开连接状态。这时第一次的连接请求经过漫长的时间到达了服务端，服务端认为客户端又需要建立连接，所以进行了连接确认回复，自己的状态变为连接已建立，但是因为客户端处于关闭节点并不会理会改报文，这样就造成了服务端连接的浪费

- 四次挥手

  - 客户端和服务端处于连接已建立可以进行数据传输

  - 客户端发起连接释放报文：FIN=1（终止符号） ACK=1（确认符号） seq=u（客户端已消耗序号+1） ack=v（确认序号） （消耗一个序号）    

    > 客户端进入终止等待1

  - 服务端发起一个普通的确认报文段：ACK=1（表示为普通的确认报文段） seq=v（服务端已传输序号+1） ack=u+1（这时对客户端请求的确认），     通知高层应用客户端要断开和服务端的连接，  此时tcp客户进程到tcp服务进程的连接已经释放了了，客户端已经没有数据需要传输，但是服务端到客户端如果还有数据需要传输客户端必需接收   

    > 服务端进入关闭等待状态

  - 客户端接收到服务端确认报文后进入

    > 客户端进入终止等待2状态

  - tcp服务端发送最终确认报文段：FIN=1 ACK=1 seq=w ack=u+1

    > 服务端进入最后确认状态

  - tcp客户端接收到最终确认报文段后，给服务端发送普通确认报文段：ACK=1 seq=u+1 ack=w+1

    > 客户端进入时间等待状态

  - 服务端在接收到确认信息

    > 服务端进入关闭状态

  - 客户端等待2msl后，最长报文段寿命，rfc建议为2分钟

    > 客户端进入关闭状态

# 3、udp

- 熟知端口号：

  - RIP        520

  - DNS      53

  - TFTP     69

  - SNMP   161

  - DHCP    67/68

# 4、应用说明

## 1、网页浏览器输入web服务器域名是如何响应的

-  客户端输入web服务器的域名www.***.com
- 客户端的DNS进程会发起一个请求报文，其内容为www.***.com域名所对应的ip地址是什么的DNS查询请求
- DNS查询请求需要封装为运输层中的UDP协议报文
  - UDP首部
    - 源端口：49152 （挑选一个客户端未使用的短暂端口号，49152～65535）
    - 目标端口：53（熟知端口号）
- 通过以太网发送给DNS服务器
- DNS服务器收到后解析UDP协议报文，将任务丢给DNS服务器的处理进程，查询到对应的ip地址之后封装成对应DNS响应报文
  - UDP首部
    - 源端口：53
    - 目标端口：49152
  - 响应内容为www.***.com域名的ip地址为192.168.0.3
- 使用UDP协议封装为UDP报文发送给用户PC
- 用户PC收到后根据端口号，将报文交给DNS客户端进程，解析响应的报文，得到域名对应的ip
- 接下来用户PC就可以给目标ip发送http报文
- 在运输车需要封装为TCP报文进行传输，目标端口为80，发送给对应的web服务器
- web服务器端处理之后给用户端发送HTTP响应报文
- 封装为TCP报文发送给客户端

**浏览器请求过程总结：**

> 客户端会通过本机的dns进程发送udp报文给dns服务器（默认为53端口）要求查询域名对应的ip地址，服务器层层查找找到对应的ip地址通过udp报文返回给客户端，客户端拿到ip地址之后，浏览器封装对应http请求，在网络模型的运输层，http会被封装为tcp请求报文发送给web服务器，服务器接收到tcp报文之后解析成对应的http报文交给对应的服务端进程处理，根据报文的要求，服务器封装对应的http响应报文，在运输层封装为tcp报文发送给客户端，客户端收到报文之后解析为http报文展示在浏览器上
>
> 备注：用户pc在解析域名的时候会首先查询浏览器中是否缓存有对应域名的ip，若没有则会在操作系统的hosts文件中查询有没有对应的域名映射的ip，若还是没有才会向dns服务器发起请求查询域名对应的域名，若是查询到ip则直接发起对应的ip请求，所以host文件中的域名映射安全很重要。

## 2、tcp和udp的对比

udp是用户数据报协议、tcp是传输控制协议的缩写

- udp可以直接发送数据，tcp协议需要三报文握手建立链接，四报文挥手释放链接（逻辑链接）
- udp支持单播放、多播、广播，简单的说就是支持1对1或者1对多的传输，tcp仅支持1对1传输
- udp不会对报文进行拆分会整体传输给接收方，tcp认为发送数据只是一连串的字节流，发送方会根据一定的策略将缓冲区的数据拿出一部分发送给接收方，接收方也会在缓冲区读取一部分数据交给应用进程处理，所以一个请求发送方的包的数量和接收方接收到的包的数量并不能保证是一致的，双方需要进行对应的实现规定好的约定进行发送和读取，以保证发送和接收处理的完整性。也就是所谓的拆包沾包和。也就是需要进行编码以及解码

- tcp可以进行双端通信
- udp向上提供的是无链接不可靠的传输服务，有可能会路由路由器丢失、因为误码被接收方，而得不到任何回应，适用于实时应用视频电话，视频会议等
- tcp不会出现传输丢失、误码等情况
- Udp报文首部只有8个字节比较简单，tcp的比较复杂